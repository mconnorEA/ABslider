<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel‐Perfect A/B Slider (clip‐path)</title>
  <style>
    /* 
      1) .slider will be set to the Before-image’s exact natural pixel dimensions 
         (via JS on load). 
      2) Both images are absolutely stacked at the same size so we can clip the After image.
    */
    .slider {
      position: relative;
      display: inline-block;  /* shrink-wrap to the fixed pixel size */
      user-select: none;      /* prevent accidental text selection while dragging */
      overflow: hidden;       /* hide any overflow by design */
    }

    /*********************************************
     “Before” image:
     - Initially in normal flow, with no forced width so the browser renders it at its 
       intrinsic (natural) pixel size. 
     - After load, JS will re‐position it to absolute but keep the same pixel size.
    *********************************************/
    .slider > img.before-img {
      display: block;
      width: auto;   /* allow intrinsic width */
      height: auto;  /* allow intrinsic height */
      position: relative; /* normal flow for initial render */
      z-index: 0;        /* below the After image */
    }

    /*********************************************
     “After” image:
     - Will be absolutely positioned at top-left (0,0) 
       once JS runs, and sized to exactly the same width/height as the Before image.
     - We apply clip-path: inset(0 [px] 0 0) so only the left portion is visible.
    *********************************************/
    .slider img.after-img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;     /* 100% of .slider (pixel‐locked by JS) */
      height: auto;    /* preserve aspect ratio */
      z-index: 1;      /* on top of Before image */
      /* clip-path will be set/updated by JS on load & on drag */
      clip-path: inset(0 50% 0 0); /* default fallback: hide right 50% */
    }

    /*********************************************
     The draggable handle (vertical bar):
     - A thin 4px-wide div that sits on top of both images (z-index: 2).
     - We move it in px as the user drags.
    *********************************************/
    .slider .handle {
      position: absolute;
      top: 0;
      left: 0;           /* JS will set to half‐width on load */
      width: 4px;        /* thickness of the divider line */
      height: 100%;      /* full slider height */
      background: rgba(255, 255, 255, 0.9);
      cursor: ew-resize;
      z-index: 2;        /* above both images */
      transform: translateX(-2px); /* center the 4px bar on its left coordinate */
    }

    /* Small circular “knob” in the middle of the handle for better UX */
    .slider .handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div class="slider" id="slider">
    <!-- 1) “Before” image in flow (natural pixel size) -->
    <img
      id="beforeImg"
      class="before-img"
      src="images/before.png"
      alt="Before image"
    />

    <!-- 2) “After” image (will be stacked & clipped via clip-path) -->
    <img
      class="after-img"
      src="images/after.png"
      alt="After image"
      id="afterImg"
    />

    <!-- 3) The draggable vertical handle -->
    <div class="handle" id="handle"></div>
  </div>

  <script>
    (function() {
      const slider    = document.getElementById('slider');
      const beforeImg = document.getElementById('beforeImg');
      const afterImg  = document.getElementById('afterImg');
      const handle    = document.getElementById('handle');
      let isDragging  = false;

      function initSlider() {
        // If the Before image hasn’t fully loaded, wait and retry
        if (!beforeImg.complete || beforeImg.naturalWidth === 0) {
          setTimeout(initSlider, 50);
          return;
        }

        // 1) Read the Before image’s natural (intrinsic) pixel size
        const naturalW = beforeImg.naturalWidth;
        const naturalH = beforeImg.naturalHeight;

        // 2) “Lock” the slider container to exactly those dimensions
        slider.style.width  = naturalW + 'px';
        slider.style.height = naturalH + 'px';

        // 3) Switch the Before image to absolute positioning 
        //    (so it stays exactly at those px dims, not fluid anymore)
        beforeImg.style.position = 'absolute';
        beforeImg.style.top  = '0';
        beforeImg.style.left = '0';
        beforeImg.style.width  = naturalW + 'px';
        beforeImg.style.height = naturalH + 'px';

        // 4) Also force the After image to exactly those same px dims
        afterImg.style.position = 'absolute';
        afterImg.style.top  = '0';
        afterImg.style.left = '0';
        afterImg.style.width  = naturalW + 'px';
        afterImg.style.height = naturalH + 'px';

        // 5) Initialize clip-path on the After image so that
        //    the right half is hidden by default (px = naturalW/2)
        const halfW = naturalW / 2; 
        afterImg.style.clipPath = `inset(0px ${halfW}px 0px 0px)`;

        // 6) Position the handle in the middle (px = halfW)
        handle.style.left = halfW + 'px';
      }

      function onDrag(e) {
        if (!isDragging) return;

        // 1) Get slider’s bounding rectangle (px coordinates on screen)
        const rect = slider.getBoundingClientRect();

        // 2) Determine pointer X in px relative to slider’s left edge
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;

        // 3) Clamp x into [0 .. sliderWidth]
        if (x < 0) x = 0;
        if (x > rect.width) x = rect.width;

        // 4) Compute how many px of the After image should remain visible
        //    → we clip everything to the right of x: clipPath inset right = sliderWidth - x
        const sliderWidth = rect.width;
        const clipRightPx = sliderWidth - x;

        // 5) Apply clip-path in px: hide the “clipRightPx” on the right side
        afterImg.style.clipPath = `inset(0px ${clipRightPx}px 0px 0px)`;

        // 6) Move the handle to x (px) so the vertical bar follows the pointer
        handle.style.left = x + 'px';
      }

      // Enable dragging when user presses down on the handle
      handle.addEventListener('mousedown', () => { isDragging = true; });
      handle.addEventListener('touchstart', () => { isDragging = true; });

      // Update clip-path & handle position as the pointer moves
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('touchmove', onDrag);

      // Stop dragging when the pointer is released
      document.addEventListener('mouseup',   () => { isDragging = false; });
      document.addEventListener('touchend', () => { isDragging = false; });

      // Initialize the slider once the page (and images) have loaded
      window.addEventListener('load', initSlider);
      // In case everything was already complete, also call it once more
      if (document.readyState === 'complete') initSlider();
    })();
  </script>
</body>
</html>
