<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom A/B Image Slider (Fixed Dimensions, Pixel Clipping)</title>
  <style>
    /* 
      1) The outer slider “.ab-slider” will be pinned to the Before-image’s 
         natural width & height, no “width:100%” tricks. 
      2) Both images will be stretched to fill this fixed‐size container, 
         so that “After” can be clipped in px without ever being resized.
    */
    .ab-slider {
      position: relative;
      display: inline-block;  /* shrink‐wrap to the Before image’s intrinsic size */
      user-select: none;      /* prevent text selection while dragging */
      overflow: hidden;       /* hide any overflow from After wrapper */
    }

    /*****************************************
     “Before” image:
     - We remove any responsive rule (no width:100%). 
     - It will render at its intrinsic (natural) size.
     - Once it’s loaded, JS will read its natural width/height 
       and set the slider <div> to exactly those px.
    *****************************************/
    .ab-slider > img.before-img {
      display: block;
      width: auto;   /* let it render at its own natural width */
      height: auto;  /* let it render at its own natural height */
      position: relative; /* keep in normal flow so .ab-slider gets that size */
      z-index: 0;        /* below the After-image overlay */
    }

    /*****************************************
     The “After” wrapper:
     - Absolutely positioned at top-left of the slider.
     - On page load, JS sets its width = half of the slider’s width in px.
     - height: 100% so it always matches the slider’s height.
     - overflow: hidden → any part of the full‐size “After” image outside that px‐width 
       is clipped (never scaled).
    *****************************************/
    .ab-slider .after {
      position: absolute;
      top: 0;
      left: 0;
      width: 0px;       /* will be set by JS on load to ½ of slider’s width */
      height: 100%;     /* match slider’s height exactly */
      overflow: hidden; /* clip child Image in px */
      z-index: 1;       /* on top of Before-image */
      pointer-events: none; /* let the handle capture drags */
    }

    /*****************************************
     The “After” image itself:
     - Absolutely positioned at (0,0) inside the slider.
     - width: 100% forces it to match the slider’s fixed pixel width exactly.
     - height: auto preserves aspect ratio.
     - Because we clip the wrapper in px, the After image will never itself shrink.
    *****************************************/
    .ab-slider .after img.after-img {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;    /* fill the slider’s width in px—never changes at drag time */
      height: auto;   /* preserve aspect ratio */
      z-index: 1;
    }

    /*****************************************
     The draggable handle (vertical bar):
     - Positioned at X px from the left (JS sets “left” in px on load and on drag).
     - width: 4px for the visible divider line.
     - height: 100% so it spans full slider height.
    *****************************************/
    .ab-slider .handle {
      position: absolute;
      top: 0;
      left: 0;           /* will be moved by JS to half‐width on load */
      width: 4px;        /* thickness of the vertical divider */
      height: 100%;      /* full slider height */
      background: rgba(255, 255, 255, 0.9);
      cursor: ew-resize;
      z-index: 2;        /* above both images */
      transform: translateX(-2px); /* center the 4px wide bar on its “left” coordinate */
    }

    /* A small circular “knob” on the handle for UX */
    .ab-slider .handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div class="ab-slider" id="mySlider">
    <!-- 1) “Before” image in normal flow (intrinsic size) -->
    <img
      class="before-img"
      src="images/before.png"
      alt="Before image"
      id="beforeImg"
    />

    <!-- 2) “After” wrapper that will be clipped in px by JS -->
    <div class="after" id="afterWrapper">
      <!-- 3) “After” image must exactly match Before’s size via width:100% in px -->
      <img
        class="after-img"
        src="images/after.png"
        alt="After image"
      />
    </div>

    <!-- 4) Draggable vertical handle -->
    <div class="handle" id="sliderHandle"></div>
  </div>

  <script>
    (function() {
      const slider       = document.getElementById('mySlider');
      const beforeImg    = document.getElementById('beforeImg');
      const afterWrapper = document.getElementById('afterWrapper');
      const handle       = document.getElementById('sliderHandle');
      let isDragging     = false;

      // Initialize slider dimensions AFTER the “Before” image has fully loaded
      function initSlider() {
        // If the Before image isn’t yet loaded, retry shortly
        if (!beforeImg.complete || beforeImg.naturalWidth === 0) {
          setTimeout(initSlider, 50);
          return;
        }

        // 1) Get the intrinsic (natural) pixel size of the Before image
        const naturalW = beforeImg.naturalWidth;
        const naturalH = beforeImg.naturalHeight;

        // 2) Force the slider container to exactly match that size in px
        slider.style.width  = naturalW + 'px';
        slider.style.height = naturalH + 'px';

        // 3) Set the After wrapper to half that width in px (initially 50% reveal)
        const halfW = naturalW / 2;
        afterWrapper.style.width = halfW + 'px';

        // 4) Place the handle exactly at halfW px (center)
        handle.style.left = halfW + 'px';
      }

      function onDrag(e) {
        if (!isDragging) return;

        // 1) Get slider’s bounding rectangle (px coords on screen)
        const rect = slider.getBoundingClientRect();

        // 2) Compute pointer’s X relative to slider’s left (in px)
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;

        // 3) Clamp x between [0 … sliderWidth]
        if (x < 0) x = 0;
        if (x > rect.width) x = rect.width;

        // 4) Apply that pixel‐width to After wrapper and move handle in px
        afterWrapper.style.width = x + 'px';
        handle.style.left = x + 'px';
      }

      // BEGIN dragging when user presses down on the handle
      handle.addEventListener('mousedown', () => { isDragging = true; });
      handle.addEventListener('touchstart', () => { isDragging = true; });

      // UPDATE on pointer move
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('touchmove', onDrag);

      // STOP dragging on pointer release
      document.addEventListener('mouseup', () => { isDragging = false; });
      document.addEventListener('touchend', () => { isDragging = false; });

      // Run initialization when the page has loaded
      window.addEventListener('load', initSlider);
      // Also do a quick check if it’s already complete
      if (document.readyState === 'complete') initSlider();
    })();
  </script>
</body>
</html>
