<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom A/B Image Slider</title>
  <style>
    /* 
      1) Make .ab-slider a positioned container of fixed (or max) width. 
      2) All child images will be absolutely positioned to fill this container.
    */
    .ab-slider {
      position: relative;
      width: 800px;       /* change to whatever max‐width you need */
      max-width: 100%;
      height: auto;       /* height will be driven by the images */
      overflow: hidden;
      margin: 0 auto;     /* center horizontally */
      user-select: none;  /* avoid weird text selection while dragging */
    }

    /* 
      Reset margins/padding if any.
      Force images to “own” no extra space, then absolutely fill the .ab-slider.
    */
    .ab-slider img {
      display: block;
      position: absolute; /* sit on top of each other */
      top: 0;
      left: 0;
      width: 100%;
      height: auto;       /* preserve aspect‐ratio */
    }

    /* 
      The “After” wrapper will literally mask (clip) the after‐image. 
      Initially: width = 50% (so you see left half). 
      height: 100% of the parent. overflow:hidden clips its child.
    */
    .ab-slider .after {
      position: absolute;
      top: 0;
      left: 0;
      width: 50%;         /* start “half revealed” */
      height: 100%;
      overflow: hidden;   /* clip anything outside width */
      pointer-events: none; /* ensure handle can capture the drag */
      z-index: 1;         /* sit above the “Before” image */
    }

    /* 
      The “After” image itself also needs to be absolutely full‐width 
      (100% of the slider, not 100% of the .after wrapper!). 
      So override the default .ab-slider img rule for images INSIDE .after.
    */
    .ab-slider .after img {
      width: 100%;        /* ALWAYS fill the full slider width */
      height: auto;       /* preserve aspect ratio */
      position: absolute; /* same top/left as the “before” img */
      top: 0;
      left: 0;
    }

    /* 
      The draggable “handle” is simply a vertical bar that moves from 0→100%. 
      We’ll update its left: % in JS.
    */
    .ab-slider .handle {
      position: absolute;
      top: 0;
      left: 50%;          /* start in the middle */
      width: 4px;         /* thickness of the bar */
      height: 100%;
      background: rgba(255, 255, 255, 0.9);
      cursor: ew-resize;
      z-index: 2;         /* above everything else */
      transform: translateX(-2px); /* center the 4px bar exactly */
    }

    /* 
      Optional: put a small “dot” in the middle of the bar for better UX 
    */
    .ab-slider .handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <!-- 
    1) BEFORE image (fills entire slider, sitting at z‐index: 0 by default).
    2) AFTER container (width=50% initially) which masks only the left half.
    3) The handle bar to drag.
  -->
  <div class="ab-slider" id="mySlider">
    <!-- “Before” (full-size) -->
    <img
      src="images/before.png"
      alt="Before image"
      style="z-index: 0;"
    />

    <!-- “After” wrapper (clipped) -->
    <div class="after">
      <img
        src="images/after.png"
        alt="After image"
        style="z-index: 1;"
      />
    </div>

    <!-- Draggable vertical bar -->
    <div class="handle" id="sliderHandle"></div>
  </div>

  <script>
    (function() {
      // Grab references
      const slider = document.getElementById('mySlider');
      const handle = document.getElementById('sliderHandle');
      const afterContainer = slider.querySelector('.after');
      let isDragging = false;

      // When pointer moves (mouse or touch), update the “reveal %”
      function onDrag(e) {
        if (!isDragging) return;

        // 1) Find slider’s bounding rect
        const rect = slider.getBoundingClientRect();

        // 2) Compute X relative to slider’s LEFT edge
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;

        // 3) Clamp x between [0, rect.width]
        if (x < 0) x = 0;
        if (x > rect.width) x = rect.width;

        // 4) Convert to percentage
        const pct = (x / rect.width) * 100;

        // 5) Update after‐wrapper width and handle position
        afterContainer.style.width = pct + '%';
        handle.style.left = pct + '%';
      }

      // Start dragging on mousedown / touchstart
      handle.addEventListener('mousedown', () => { isDragging = true; });
      handle.addEventListener('touchstart', () => { isDragging = true; });

      // Listen for pointer movements
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('touchmove', onDrag);

      // End dragging on mouseup / touchend
      document.addEventListener('mouseup', () => { isDragging = false; });
      document.addEventListener('touchend', () => { isDragging = false; });
    })();
  </script>
</body>
</html>
