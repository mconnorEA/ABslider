<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom A/B Image Slider</title>
  <style>
    /***************************************
     1) Let the “Before” image live in normal flow.
        That way, `.ab-slider` automatically takes on its width & height.
     2) We only absolutely position the “After” image on top, and clip its container.
    ***************************************/
    .ab-slider {
      position: relative;
      display: inline-block; /* shrink‐wrap to the Before image size */
      user-select: none;     /* prevent accidental text selection while dragging */
    }

    /***************************************
     “Before” image:
     • Normal flow → lets .ab-slider inherit its intrinsic size.
     • width: 100% (of its own natural/native width) so it’s responsive if the browser shrinks.
    ***************************************/
    .ab-slider > img.before-img {
      display: block;
      width: 100%;   /* fill whatever container it’s in (or native width by default) */
      height: auto;  /* maintain aspect ratio */
      position: relative; /* remain in normal flow */
      z-index: 0;        /* below the After image */
    }

    /***************************************
     The “After” wrapper:
     • Absolutely positioned atop the Before image.
     • “width: 50%” means “show half of the After image initially.”
     • “height: 100%” ensures it matches the Before image’s height.
     • “overflow: hidden” truly clips the After image inside this box.
    ***************************************/
    .ab-slider .after {
      position: absolute;
      top: 0;
      left: 0;
      width: 50%;       /* reveal 50% of the After image at start */
      height: 100%;     /* match the Before image’s height exactly */
      overflow: hidden; /* clip any part of the After image that spills out */
      z-index: 1;       /* on top of the Before image */
      pointer-events: none; /* so the handle (below) still captures drags */
    }

    /***************************************
     The “After” image itself:
     • Absolutely positioned exactly on top of the Before image.
     • “width: 100%” forces it to match the entire slider width—in other words,
       it always stays the same size as the Before image, never “shrinks.” 
     • Because .after is “overflow:hidden,” you only see the left portion of it.
    ***************************************/
    .ab-slider .after img.after-img {
      position: absolute; /* stack exactly on top of the Before image */
      top: 0;
      left: 0;
      width: 100%;        /* always fill the slider’s full width */
      height: auto;       /* maintain aspect ratio */
      z-index: 1;
    }

    /***************************************
     The draggable “handle” (vertical bar):
     • We position it at 50% to begin with.
     • Its left:XX% will shift as you drag.
    ***************************************/
    .ab-slider .handle {
      position: absolute;
      top: 0;
      left: 50%;          /* start in the middle */
      width: 4px;         /* thickness of the divider line */
      height: 100%;       /* full slider height */
      background: rgba(255, 255, 255, 0.9);
      cursor: ew-resize;
      z-index: 2;         /* on top of both images */
      transform: translateX(-2px); /* center the 4px-wide bar */
    }

    /* Optional: small circular “dot” on the handle for better UX */
    .ab-slider .handle::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 12px;
      height: 12px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div class="ab-slider" id="mySlider">
    <!-- 1) “Before” image: stays in flow and sets the slider’s size -->
    <img
      class="before-img"
      src="images/before.png"
      alt="Before image"
    />

    <!-- 2) “After” wrapper: starts at 50% width, clips its child -->
    <div class="after">
      <!-- 3) “After” image: always 100% width, sits exactly on top of Before -->
      <img
        class="after-img"
        src="images/after.png"
        alt="After image"
      />
    </div>

    <!-- 4) The draggable handle -->
    <div class="handle" id="sliderHandle"></div>
  </div>

  <script>
    (function() {
      const slider = document.getElementById('mySlider');
      const handle = document.getElementById('sliderHandle');
      const afterContainer = slider.querySelector('.after');
      let isDragging = false;

      function onDrag(e) {
        if (!isDragging) return;

        // 1) Get slider’s bounding rectangle
        const rect = slider.getBoundingClientRect();

        // 2) Compute X relative to slider’s left edge
        let x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;

        // 3) Clamp x between [0 .. rect.width]
        if (x < 0) x = 0;
        if (x > rect.width) x = rect.width;

        // 4) Convert x→percentage in [0..100]
        const pct = (x / rect.width) * 100;

        // 5) Apply that pct to the “After” wrapper width and the handle position
        afterContainer.style.width = pct + '%';
        handle.style.left = pct + '%';
      }

      // Begin dragging when user presses down on the handle
      handle.addEventListener('mousedown', () => { isDragging = true; });
      handle.addEventListener('touchstart', () => { isDragging = true; });

      // Update while moving pointer
      document.addEventListener('mousemove', onDrag);
      document.addEventListener('touchmove', onDrag);

      // Stop dragging on release
      document.addEventListener('mouseup', () => { isDragging = false; });
      document.addEventListener('touchend', () => { isDragging = false; });
    })();
  </script>
</body>
</html>
